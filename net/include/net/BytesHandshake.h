#pragma once

#include <memory>

#include <crypto/Common.h>
#include <net/BytesSocket.h>
#include <net/BytesFrameCoder.h>
#include <net/Common.h>

#include <boost/asio.hpp>

namespace net {

static const unsigned c_rlpxVersion = 4;

class BytesHandshake : public std::enable_shared_from_this<BytesHandshake> {
    friend class BytesFrameCoder;

public:
    // setup incoming connection
    BytesHandshake(Host *host, std::shared_ptr<BytesSocket> const& socket) :
        m_host(host), m_originated(false), m_socket(socket), m_idleTimer(m_socket->ref().get_io_service()) {
        //crypto::Nonce::get().ref().copyTo(m_nonce.ref());
    }

    // setup outbound connection
    BytesHandshake(Host *host, std::shared_ptr<BytesSocket> const& socket, NodeID remote) :
        m_host(host), m_remote(remote), m_originated(true), m_socket(socket), m_idleTimer(m_socket->ref().get_io_service()) {
        //crypto::Nonce::get().ref().copyTo(m_nonce.ref());
    }

    virtual ~BytesHandshake() = default;

    // start handshake
    void start();

    // abort
    void cancel();

protected:
    // Sequential states of handshake
    enum State {
        Error = -1,
        New = 0,
        AckAuth,
        AckAuthEIP8,
        WriteHello,
        ReadHello,
        StartSession,
    };

    // write auth message to socket and transitions to AckAuth
    void writeAuth();

    // read auth message from socet and transiations to AckAuth
    void readAuth();

    // continues to reading auth message in EIP8 format and transitions to AckAuthEIP8.
    void readAuthEIP8();

    // derives ephemeral secret from signature and set members after Auth has been decryoted
    void setAuthValues(Signature const& sig, Public const& remotePubk, h256 const& remoteNonce, uint64_t remoteVersion);

    // write ack message to socket and transitions to WriteHello
    void writeAck();

    // write ack message in EIP-8 format to socket and transitions to WriteHello
    void writeAckEIP8();

    // reads auth message from socket and tansitions to WriteHello
    void readAck();

    // continues reading ack message in eip-8 format and transitions to WriteHello
    void readAckEIP8();

    // close
    void error();

    // preforms transition for m_nextState
    virtual void transition(boost::system::error_code ec = boost::system::error_code());

    // timeout for remote to respond to transition events. Enforced by m_idleTimer and refreshed by transition()
    boost::posix_time::milliseconds const c_timeout = boost::posix_time::milliseconds(1800);
    State m_nextState = New;    //
    bool m_cancel = false;
    Host *m_host;
    NodeID m_remote;            // Public address of remote host
    bool m_originated = false;  // True if connect is outbound

    // Buffers for encoded and decoded handshake phases
    bytes m_auth;					//< Plaintext of egress or ingress Auth message.
    bytes m_authCipher;				//< Ciphertext of egress or ingress Auth message.
    bytes m_ack;					//< Plaintext of egress or ingress Ack message.
    bytes m_ackCipher;				//< Ciphertext of egress or ingress Ack message.
    bytes m_handshakeOutBuffer;		//< Frame buffer for egress Hello packet.
    bytes m_handshakeInBuffer;		//< Frame buffer for ingress Hello packet.

    GKey m_ecdheLocal = GKey::create(); // Ephemeral ECDH secret and agreement.
    h256 m_nonce;   // Nonce generate by this host for handshake

    Public m_ecdheRemote;   // Remote ephemeral public key
    h256 m_remoteNonce;     // Nonce generated by remote host for handshake
    uint64_t m_remoteVersion;

    std::unique_ptr<BytesFrameCoder> m_io;
    std::shared_ptr<BytesSocket> m_socket;
    boost::asio::deadline_timer m_idleTimer; // timer which enforcess c_timeout

    Logger m_logger{createLogger(VerbosityTrace, "net")};
};


} // end namespace